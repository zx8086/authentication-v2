/* test/bun/circuit-breaker-error-classification.test.ts */

import { describe, expect, it, beforeEach } from "bun:test";
import { SharedCircuitBreakerService } from "../../src/services/shared-circuit-breaker.service";
import { KongApiError } from "../../src/adapters/kong-utils";

describe("Circuit Breaker Error Classification", () => {
  beforeEach(() => {
    // Reset singleton between tests
    SharedCircuitBreakerService.resetInstance();
  });

  it("should NOT count 404 errors as circuit breaker failures", async () => {
    const circuitBreaker = SharedCircuitBreakerService.getInstance(
      {
        enabled: true,
        timeout: 1000,
        errorThresholdPercentage: 50,
        resetTimeout: 5000,
        rollingCountTimeout: 10000,
        rollingCountBuckets: 10,
        volumeThreshold: 2,
      },
      {
        enabled: true,
        strategy: "local-memory",
        ttlSeconds: 300,
        maxItems: 1000,
        compressionEnabled: false,
        staleDataToleranceMinutes: 5,
      }
    );

    let operationCount = 0;
    let successCount = 0;

    // Simulate multiple 404 errors (consumer not found)
    for (let i = 0; i < 5; i++) {
      const result = await circuitBreaker.wrapKongOperation(
        "getConsumerSecret",
        async () => {
          operationCount++;
          throw new KongApiError("Consumer not found", 404, "Not Found");
        }
      );

      // Should return null (not found) without opening circuit
      expect(result).toBeNull();
    }

    // Now try a successful operation - circuit should still be closed
    const successResult = await circuitBreaker.wrapKongOperation(
      "getConsumerSecret",
      async () => {
        operationCount++;
        successCount++;
        return { id: "test", key: "test-key", secret: "test-secret", consumer: { id: "test-consumer" } };
      }
    );

    expect(successResult).toBeTruthy();
    expect(operationCount).toBe(6);
    expect(successCount).toBe(1);

    // Verify circuit breaker is still closed
    const stats = circuitBreaker.getStats();
    expect(stats.kong_operations?.state).toBe("closed");
  });

  it("should count 500 errors as circuit breaker failures", async () => {
    const circuitBreaker = SharedCircuitBreakerService.getInstance(
      {
        enabled: true,
        timeout: 1000,
        errorThresholdPercentage: 50,
        resetTimeout: 5000,
        rollingCountTimeout: 10000,
        rollingCountBuckets: 10,
        volumeThreshold: 2,
      },
      {
        enabled: true,
        strategy: "local-memory",
        ttlSeconds: 300,
        maxItems: 1000,
        compressionEnabled: false,
        staleDataToleranceMinutes: 5,
      }
    );

    let operationCount = 0;

    // Simulate 500 errors (infrastructure failures) - these should count as failures
    try {
      for (let i = 0; i < 3; i++) {
        await circuitBreaker.wrapKongOperation(
          "getConsumerSecret",
          async () => {
            operationCount++;
            throw new KongApiError("Internal server error", 500, "Internal Server Error");
          }
        );
      }
    } catch (error) {
      // Expected to throw on the last attempt due to circuit opening
    }

    expect(operationCount).toBeGreaterThan(0);

    // With 50% error threshold and 2 volume threshold, circuit should open after 2-3 failures
    const stats = circuitBreaker.getStats();
    // Circuit should be open due to infrastructure failures
    expect(stats.kong_operations?.state).toBe("open");
    expect(stats.kong_operations?.stats?.failures).toBeGreaterThan(0);
  });

  it("should distinguish between business logic and infrastructure errors", async () => {
    const circuitBreaker = SharedCircuitBreakerService.getInstance(
      {
        enabled: true,
        timeout: 1000,
        errorThresholdPercentage: 80, // Higher threshold to avoid opening too quickly
        resetTimeout: 5000,
        rollingCountTimeout: 10000,
        rollingCountBuckets: 10,
        volumeThreshold: 5,
      },
      {
        enabled: true,
        strategy: "local-memory",
        ttlSeconds: 300,
        maxItems: 1000,
        compressionEnabled: false,
        staleDataToleranceMinutes: 5,
      }
    );

    // Mix of business logic errors (should NOT count as failures)
    const businessLogicErrors = [
      new KongApiError("Consumer not found", 404, "Not Found"),
      new KongApiError("Unauthorized", 401, "Unauthorized"),
      new KongApiError("Forbidden", 403, "Forbidden"),
      new KongApiError("Conflict", 409, "Conflict"),
    ];

    // These should not trigger circuit breaker
    for (const error of businessLogicErrors) {
      const result = await circuitBreaker.wrapKongOperation(
        "testOperation",
        async () => {
          throw error;
        }
      );
      expect(result).toBeNull();
    }

    // Circuit should still be closed after business logic errors
    let stats = circuitBreaker.getStats();
    expect(stats.kong_operations?.state).toBe("closed");

    // Now add some infrastructure errors
    const infrastructureErrors = [
      new KongApiError("Service unavailable", 503, "Service Unavailable"),
      new KongApiError("Internal server error", 500, "Internal Server Error"),
    ];

    try {
      for (const error of infrastructureErrors) {
        await circuitBreaker.wrapKongOperation(
          "testOperation",
          async () => {
            throw error;
          }
        );
      }
    } catch (error) {
      // Expected to potentially throw
    }

    // Now circuit may have opened due to infrastructure errors
    stats = circuitBreaker.getStats();
    // Circuit state depends on exact timing and thresholds, but failures should be recorded
    expect(stats.kong_operations?.stats?.failures).toBeGreaterThan(0);
  });

  it("should handle timeout and network errors as infrastructure failures", async () => {
    const circuitBreaker = SharedCircuitBreakerService.getInstance(
      {
        enabled: true,
        timeout: 1000,
        errorThresholdPercentage: 50,
        resetTimeout: 5000,
        rollingCountTimeout: 10000,
        rollingCountBuckets: 10,
        volumeThreshold: 2,
      },
      {
        enabled: true,
        strategy: "local-memory",
        ttlSeconds: 300,
        maxItems: 1000,
        compressionEnabled: false,
        staleDataToleranceMinutes: 5,
      }
    );

    // Test timeout error
    try {
      await circuitBreaker.wrapKongOperation(
        "testOperation",
        async () => {
          const timeoutError = new Error("Request timeout");
          timeoutError.name = "TimeoutError";
          throw timeoutError;
        }
      );
    } catch (error) {
      // Expected
    }

    // Test AbortError (fetch timeout)
    try {
      await circuitBreaker.wrapKongOperation(
        "testOperation",
        async () => {
          const abortError = new Error("Request was aborted");
          abortError.name = "AbortError";
          throw abortError;
        }
      );
    } catch (error) {
      // Expected
    }

    // These should count as failures and potentially open the circuit
    const stats = circuitBreaker.getStats();
    expect(stats.kong_operations?.stats?.failures).toBeGreaterThan(0);
  });
});