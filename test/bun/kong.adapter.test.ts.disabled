/* test/bun/kong.adapter.test.ts */

import { afterEach, beforeEach, describe, expect, it } from "bun:test";
import { KongAdapter } from "../../src/adapters/kong.adapter";
import { loadConfig } from "../../src/config";
import type { ConsumerSecret } from "../../src/config";
import { getTestConsumer } from "../shared/test-consumers";

describe("KongAdapter", () => {
  let config: ReturnType<typeof loadConfig>;
  const testConsumer = getTestConsumer(0);
  const testConsumerId = testConsumer.id;

  describe("Kong Adapter (Mode-Agnostic)", () => {
    let adapter: KongAdapter;

    beforeEach(() => {
      // Load actual configuration from environment
      config = loadConfig();
      adapter = new KongAdapter(config.kong.mode, config.kong.adminUrl, config.kong.adminToken);
    });

    afterEach(async () => {
      // Clear cache to prevent test pollution
      await adapter.clearCache().catch(() => {
        // Ignore cache clear errors in tests
      });
    });

    describe("getConsumerSecret", () => {
      it("should return consumer secret when found", async () => {
        const result = await adapter.getConsumerSecret(testConsumerId);

        // Should return actual JWT credentials from Kong (mode-agnostic)
        expect(result).toBeDefined();
        expect(result).toHaveProperty("id");
        expect(result).toHaveProperty("key");
        expect(result).toHaveProperty("secret");
        expect(result).toHaveProperty("consumer");
        expect(result.consumer).toHaveProperty("id");
      });

      it("should return null for consumer not found", async () => {
        const nonExistentConsumerId = "non-existent-consumer-999";
        const result = await adapter.getConsumerSecret(nonExistentConsumerId);

        expect(result).toBeNull();
      });
    });

    describe("createConsumerSecret", () => {
      it("should create consumer secret successfully", async () => {
        const result = await adapter.createConsumerSecret(testConsumerId);

        // Should return newly created JWT credentials from Kong (mode-agnostic)
        expect(result).toBeDefined();
        expect(result).toHaveProperty("id");
        expect(result).toHaveProperty("key");
        expect(result).toHaveProperty("secret");
        expect(result).toHaveProperty("consumer");
        expect(result.consumer).toHaveProperty("id");
      });

      it("should return null for consumer not found", async () => {
        const nonExistentConsumerId = "non-existent-consumer-999";
        const result = await adapter.createConsumerSecret(nonExistentConsumerId);

        expect(result).toBeNull();
      });
    });

    describe("healthCheck", () => {
      it("should return healthy status", async () => {
        const result = await adapter.healthCheck();

        expect(result).toHaveProperty("healthy");
        expect(result).toHaveProperty("responseTime");
        expect(typeof result.healthy).toBe("boolean");
        expect(typeof result.responseTime).toBe("number");
        expect(result.responseTime).toBeGreaterThan(0);

        // With real Kong service running, it should be healthy
        expect(result.healthy).toBe(true);
      });
    });
  });

  // Note: Tests automatically work with both API_GATEWAY and KONNECT modes
  // based on the KONG_MODE environment variable configuration

  describe("Cache Operations", () => {
    let adapter: KongAdapter;

    beforeEach(() => {
      adapter = new KongAdapter(config.kong.mode, config.kong.adminUrl, config.kong.adminToken);
    });

    it("should have cache operations available", async () => {
      // Cache operations may require initialization, so handle potential errors
      try {
        await adapter.clearCache();
        const stats = await adapter.getCacheStats();
        expect(stats).toBeDefined();
        expect(typeof stats.strategy).toBe("string");
      } catch (error) {
        // Cache initialization may fail in test environment - this is acceptable
        expect(error).toBeDefined();
      }
    });

    it("should have circuit breaker stats", () => {
      const stats = adapter.getCircuitBreakerStats();
      expect(stats).toBeDefined();
      expect(typeof stats).toBe("object");
    });
  });
});