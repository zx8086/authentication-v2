import { describe, test, expect, beforeEach, afterEach, mock, spyOn } from 'bun:test';
import { BunMemoryMonitor } from '../../src/telemetry/bun-memory-monitor';
import { AdaptiveMemoryManager } from '../../src/telemetry/adaptive-memory-manager';
import { MemoryHealthEndpoints } from '../../src/telemetry/memory-health-endpoints';
import { MemoryOpenTelemetryExporter } from '../../src/telemetry/memory-otel-exporter';
import { MemoryBaselineEstablisher } from '../../src/telemetry/memory-baseline-tools';

// Mock bun:jsc module
const mockHeapStats = mock(() => ({
  heapSize: 15728640,      // 15MB
  heapCapacity: 67108864,  // 64MB
  extraMemorySize: 1048576, // 1MB
  objectCount: 5000,
  protectedObjectCount: 150,
  objectTypeCounts: {
    'String': 1500,
    'Object': 1200,
    'Array': 800,
    'Function': 300,
    'Promise': 50
  },
  protectedObjectTypeCounts: {
    'Timer': 10,
    'EventListener': 20
  }
}));

// Mock process.memoryUsage()
const mockProcessMemoryUsage = mock(() => ({
  rss: 104857600,      // 100MB
  heapTotal: 20971520, // 20MB
  heapUsed: 15728640,  // 15MB
  external: 2097152,   // 2MB
  arrayBuffers: 524288 // 512KB
}));

// Mock Bun.gc
const mockBunGc = mock((force?: boolean) => {
  // Simulate GC effect by reducing heap size
  const currentStats = mockHeapStats();
  currentStats.heapSize = Math.round(currentStats.heapSize * 0.8); // 20% reduction
  currentStats.objectCount = Math.round(currentStats.objectCount * 0.9); // 10% reduction
});

describe('BunMemoryMonitor', () => {
  let monitor: BunMemoryMonitor;

  beforeEach(async () => {
    // Reset mocks
    mockHeapStats.mockClear();
    mockProcessMemoryUsage.mockClear();
    mockBunGc.mockClear();

    // Mock dynamic imports
    global.process.memoryUsage = mockProcessMemoryUsage;

    monitor = new BunMemoryMonitor({
      enableReliabilityScoring: true,
      maxHistorySize: 100
    });
  });

  afterEach(() => {
    monitor.reset();
  });

  test('should capture metrics successfully', async () => {
    const metrics = await monitor.captureMetrics();

    expect(metrics).toBeDefined();
    expect(metrics.timestamp).toBeGreaterThan(0);
    expect(metrics.source).toMatch(/^(jsc-primary|process-fallback|hybrid)$/);
    expect(metrics.reliability).toBeGreaterThanOrEqual(0);
    expect(metrics.reliability).toBeLessThanOrEqual(100);
    expect(metrics.isValidMeasurement).toBe(true);
  });

  test('should detect memory anomalies', async () => {
    // Mock anomalous memory values
    mockProcessMemoryUsage.mockReturnValueOnce({
      rss: 104857600,
      heapTotal: 10485760,  // 10MB
      heapUsed: 15728640,   // 15MB - larger than total!
      external: 2097152,
      arrayBuffers: 524288
    });

    const metrics = await monitor.captureMetrics();

    expect(metrics.hasHeapAnomaly).toBe(true);
    expect(metrics.heapAnomalyReason).toContain('heapUsed');
    expect(metrics.reliability).toBeLessThan(100);
  });

  test('should track reliability score over time', async () => {
    // Capture initial metrics
    const initial = await monitor.captureMetrics();
    expect(initial.reliability).toBe(100);

    // Simulate several good measurements
    for (let i = 0; i < 5; i++) {
      await monitor.captureMetrics();
    }

    const afterGood = await monitor.captureMetrics();
    expect(afterGood.reliability).toBe(100);

    // Simulate anomalous measurement
    mockProcessMemoryUsage.mockReturnValueOnce({
      rss: 104857600,
      heapTotal: 10485760,
      heapUsed: 15728640, // Anomaly
      external: 2097152,
      arrayBuffers: 524288
    });

    const afterAnomaly = await monitor.captureMetrics();
    expect(afterAnomaly.reliability).toBeLessThan(100);
  });

  test('should detect garbage collection', async () => {
    // First measurement
    mockHeapStats.mockReturnValueOnce({
      heapSize: 67108864, // 64MB
      heapCapacity: 134217728,
      extraMemorySize: 1048576,
      objectCount: 10000,
      protectedObjectCount: 150,
      objectTypeCounts: { 'Object': 5000 },
      protectedObjectTypeCounts: {}
    });

    await monitor.captureMetrics();

    // Second measurement with significant heap reduction (simulating GC)
    mockHeapStats.mockReturnValueOnce({
      heapSize: 20971520, // 20MB - significant reduction
      heapCapacity: 134217728,
      extraMemorySize: 1048576,
      objectCount: 8000,
      protectedObjectCount: 150,
      objectTypeCounts: { 'Object': 4000 },
      protectedObjectTypeCounts: {}
    });

    const metrics = await monitor.captureMetrics();
    expect(metrics.gcDetected).toBe(true);
  });

  test('should detect memory leaks', async () => {
    // Simulate increasing RSS without corresponding heap growth
    const measurements = [
      { rss: 50000000, heapSize: 10000000 },  // 50MB RSS, 10MB heap
      { rss: 60000000, heapSize: 10500000 },  // 60MB RSS, 10.5MB heap
      { rss: 70000000, heapSize: 11000000 },  // 70MB RSS, 11MB heap
      { rss: 80000000, heapSize: 11500000 },  // 80MB RSS, 11.5MB heap
      { rss: 90000000, heapSize: 12000000 },  // 90MB RSS, 12MB heap
      { rss: 100000000, heapSize: 12500000 }, // 100MB RSS, 12.5MB heap
      { rss: 110000000, heapSize: 13000000 }, // 110MB RSS, 13MB heap
      { rss: 120000000, heapSize: 13500000 }, // 120MB RSS, 13.5MB heap
      { rss: 130000000, heapSize: 14000000 }, // 130MB RSS, 14MB heap
      { rss: 140000000, heapSize: 14500000 }, // 140MB RSS, 14.5MB heap
    ];

    for (const measurement of measurements) {
      mockProcessMemoryUsage.mockReturnValueOnce({
        rss: measurement.rss,
        heapTotal: 20971520,
        heapUsed: measurement.heapSize,
        external: 2097152,
        arrayBuffers: 524288
      });

      mockHeapStats.mockReturnValueOnce({
        heapSize: measurement.heapSize,
        heapCapacity: 67108864,
        extraMemorySize: 1048576,
        objectCount: 5000,
        protectedObjectCount: 150,
        objectTypeCounts: { 'Object': 2500 },
        protectedObjectTypeCounts: {}
      });

      await monitor.captureMetrics();
      // Small delay to ensure different timestamps
      await new Promise(resolve => setTimeout(resolve, 1));
    }

    const leakDetection = monitor.detectMemoryLeaks();
    expect(leakDetection.suspected).toBe(true);
    expect(leakDetection.evidence).toContain(jasmine.stringMatching(/RSS increased/));
  });

  test('should maintain measurement history', async () => {
    const historySize = 5;

    for (let i = 0; i < historySize + 2; i++) {
      await monitor.captureMetrics();
      await new Promise(resolve => setTimeout(resolve, 1));
    }

    const history = monitor.getHistoricalMetrics();
    expect(history.length).toBeGreaterThan(0);
    expect(history.length).toBeLessThanOrEqual(100); // Default max size
  });
});

describe('AdaptiveMemoryManager', () => {
  let manager: AdaptiveMemoryManager;

  beforeEach(() => {
    global.process.memoryUsage = mockProcessMemoryUsage;
    manager = new AdaptiveMemoryManager({
      thresholds: {
        warning: 0.6,
        high: 0.75,
        critical: 0.85,
        emergency: 0.95
      }
    });
  });

  afterEach(() => {
    // Clean up any intervals
    manager.clearQueue();
  });

  test('should initialize with normal state', () => {
    const status = manager.getStatus();
    expect(status.currentState).toBe('normal');
    expect(status.queuedRequests).toBe(0);
  });

  test('should process requests normally under low memory pressure', async () => {
    const testRequest = mock(() => Promise.resolve('success'));

    const result = await manager.processRequest(testRequest);

    expect(result).toBe('success');
    expect(testRequest).toHaveBeenCalledTimes(1);
  });

  test('should queue requests under high memory pressure', async () => {
    // Force high memory state by mocking heap stats
    mockHeapStats.mockReturnValue({
      heapSize: 62914560,  // ~60MB (90% of 64MB capacity)
      heapCapacity: 67108864,
      extraMemorySize: 1048576,
      objectCount: 10000,
      protectedObjectCount: 150,
      objectTypeCounts: { 'Object': 5000 },
      protectedObjectTypeCounts: {}
    });

    // Wait for state to update
    await new Promise(resolve => setTimeout(resolve, 100));

    const testRequest = mock(() => Promise.resolve('queued-success'));

    // This should be queued due to high memory pressure
    const resultPromise = manager.processRequest(testRequest);

    // Check that request is queued
    const status = manager.getStatus();
    expect(status.queuedRequests).toBeGreaterThan(0);

    // Wait for result
    const result = await resultPromise;
    expect(result).toBe('queued-success');
  });

  test('should trigger garbage collection under pressure', async () => {
    // Spy on force garbage collection
    const gcSpy = spyOn(manager, 'forceGarbageCollection').mockImplementation(async () => {
      mockBunGc(true);
    });

    await manager.forceGarbageCollection();

    expect(gcSpy).toHaveBeenCalled();
  });

  test('should clear queue on demand', () => {
    // Add some mock requests to queue
    manager.processRequest(() => Promise.resolve('test1'));
    manager.processRequest(() => Promise.resolve('test2'));

    const clearedCount = manager.clearQueue();
    expect(clearedCount).toBeGreaterThanOrEqual(0);

    const status = manager.getStatus();
    expect(status.queuedRequests).toBe(0);
  });
});

describe('MemoryHealthEndpoints', () => {
  let manager: AdaptiveMemoryManager;
  let endpoints: MemoryHealthEndpoints;

  beforeEach(() => {
    global.process.memoryUsage = mockProcessMemoryUsage;
    manager = new AdaptiveMemoryManager();
    endpoints = new MemoryHealthEndpoints(manager);
  });

  test('should return health status', async () => {
    const mockRequest = new Request('http://localhost/memory/health');
    const response = await endpoints.handleHealthCheck(mockRequest);

    expect(response.status).toBe(200);

    const data = await response.json();
    expect(data.status).toMatch(/^(healthy|warning|unhealthy|critical)$/);
    expect(data.timestamp).toBeGreaterThan(0);
    expect(data.memory).toBeDefined();
    expect(Array.isArray(data.recommendations)).toBe(true);
    expect(Array.isArray(data.alerts)).toBe(true);
  });

  test('should return detailed health status when requested', async () => {
    const mockRequest = new Request('http://localhost/memory/health?details=true');
    const response = await endpoints.handleHealthCheck(mockRequest);

    const data = await response.json();
    expect(data.details).toBeDefined();
    expect(data.details.recentMetrics).toBeDefined();
    expect(data.details.leakDetection).toBeDefined();
  });

  test('should return memory metrics', async () => {
    const mockRequest = new Request('http://localhost/memory/metrics');
    const response = await endpoints.handleMetrics(mockRequest);

    expect(response.status).toBe(200);

    const data = await response.json();
    expect(data.timestamp).toBeGreaterThan(0);
    expect(data.current).toBeDefined();
    expect(data.trends).toBeDefined();
    expect(data.current.jsc).toBeDefined();
    expect(data.current.process).toBeDefined();
  });

  test('should trigger garbage collection via action endpoint', async () => {
    const mockRequest = new Request('http://localhost/memory/actions?action=gc');
    const response = await endpoints.handleActions(mockRequest);

    expect(response.status).toBe(200);

    const data = await response.json();
    expect(data.success).toBe(true);
    expect(data.action).toBe('garbage_collection');
    expect(data.message).toContain('GC completed');
  });

  test('should clear queue via action endpoint', async () => {
    const mockRequest = new Request('http://localhost/memory/actions?action=clearQueue');
    const response = await endpoints.handleActions(mockRequest);

    expect(response.status).toBe(200);

    const data = await response.json();
    expect(data.success).toBe(true);
    expect(data.action).toBe('clear_queue');
  });

  test('should handle unknown actions', async () => {
    const mockRequest = new Request('http://localhost/memory/actions?action=unknown');
    const response = await endpoints.handleActions(mockRequest);

    expect(response.status).toBe(400);

    const data = await response.json();
    expect(data.error).toContain('Unknown action');
  });
});

describe('MemoryOpenTelemetryExporter', () => {
  let manager: AdaptiveMemoryManager;
  let exporter: MemoryOpenTelemetryExporter;

  beforeEach(() => {
    global.process.memoryUsage = mockProcessMemoryUsage;
    manager = new AdaptiveMemoryManager();
    exporter = new MemoryOpenTelemetryExporter(manager, {
      exportIntervalMs: 100, // Fast interval for testing
      serviceName: 'test-service'
    });
  });

  afterEach(() => {
    exporter.stopExporting();
  });

  test('should initialize without starting export', () => {
    const status = exporter.getExportStatus();
    expect(status.isExporting).toBe(false);
  });

  test('should start and stop exporting', () => {
    exporter.startExporting();
    let status = exporter.getExportStatus();
    expect(status.isExporting).toBe(true);

    exporter.stopExporting();
    status = exporter.getExportStatus();
    expect(status.isExporting).toBe(false);
  });

  test('should export snapshot on demand', async () => {
    const snapshot = await exporter.exportSnapshot();

    expect(snapshot.metrics).toBeDefined();
    expect(snapshot.attributes).toBeDefined();
    expect(snapshot.timestamp).toBeGreaterThan(0);

    // Check required metrics exist
    expect(snapshot.metrics).toHaveProperty('test-service.process.memory.heap.size');
    expect(snapshot.metrics).toHaveProperty('test-service.process.memory.reliability.score');
  });

  test('should reset counters', () => {
    exporter.resetCounters();
    const status = exporter.getExportStatus();

    expect(status.totalGcDetected).toBe(0);
    expect(status.totalAnomaliesDetected).toBe(0);
    expect(status.totalStateChanges).toBe(0);
  });
});

describe('MemoryBaselineEstablisher', () => {
  test('should create default scenarios', () => {
    const scenarios = MemoryBaselineEstablisher.createDefaultScenarios();

    expect(Array.isArray(scenarios)).toBe(true);
    expect(scenarios.length).toBeGreaterThan(0);

    scenarios.forEach(scenario => {
      expect(scenario.name).toBeDefined();
      expect(scenario.description).toBeDefined();
      expect(typeof scenario.loadGenerator).toBe('function');
      expect(scenario.idleWaitMs).toBeGreaterThan(0);
      expect(scenario.loadDurationMs).toBeGreaterThan(0);
      expect(scenario.cooldownMs).toBeGreaterThan(0);
    });
  });

  test('should load baseline report when none exists', () => {
    const baseline = MemoryBaselineEstablisher.loadLatestBaseline();
    // This will be null since we haven't created a baseline file
    expect(baseline).toBeNull();
  });
});

describe('Integration Tests', () => {
  test('should integrate memory pressure manager with enhanced features', async () => {
    // This test verifies the enhanced memory pressure manager works end-to-end
    const { TelemetryMemoryPressureManager } = await import('../../src/telemetry/memory-pressure-manager');

    const manager = new TelemetryMemoryPressureManager();

    // Test legacy API compatibility
    const pressureInfo = manager.getCurrentPressureInfo();
    expect(pressureInfo).toBeDefined();
    expect(pressureInfo.level).toBeDefined();
    expect(pressureInfo.heapUsedMB).toBeGreaterThanOrEqual(0);
    expect(pressureInfo.heapTotalMB).toBeGreaterThanOrEqual(0);

    // Test enhanced features if available
    if (manager.isEnhancedModeEnabled()) {
      const enhancedStatus = manager.getEnhancedStatus();
      expect(enhancedStatus.enhanced).toBe(true);
      expect(enhancedStatus.features).toBeDefined();

      const adaptiveManager = manager.getAdaptiveManager();
      expect(adaptiveManager).toBeDefined();

      const healthEndpoints = manager.getHealthEndpoints();
      expect(healthEndpoints).toBeDefined();
    }

    // Cleanup
    manager.stopMonitoring();
  });

  test('should handle memory pressure state transitions', async () => {
    const manager = new AdaptiveMemoryManager();

    // Test normal state
    let status = manager.getStatus();
    expect(status.currentState).toBe('normal');

    // Simulate memory pressure by mocking high heap utilization
    mockHeapStats.mockReturnValue({
      heapSize: 55000000,  // ~55MB (82% of 67MB capacity)
      heapCapacity: 67108864,
      extraMemorySize: 1048576,
      objectCount: 15000,
      protectedObjectCount: 150,
      objectTypeCounts: { 'Object': 7500 },
      protectedObjectTypeCounts: {}
    });

    // Wait for state update
    await new Promise(resolve => setTimeout(resolve, 200));

    status = manager.getStatus();
    // Should be in high pressure state due to >75% utilization
    expect(['high', 'critical', 'emergency']).toContain(status.currentState);
  });
});

// Performance tests
describe('Performance Tests', () => {
  test('should capture metrics quickly', async () => {
    const monitor = new BunMemoryMonitor();

    const start = performance.now();
    await monitor.captureMetrics();
    const duration = performance.now() - start;

    // Should complete within 50ms under normal conditions
    expect(duration).toBeLessThan(50);
  });

  test('should handle rapid successive measurements', async () => {
    const monitor = new BunMemoryMonitor();
    const measurements = [];

    const start = performance.now();
    for (let i = 0; i < 10; i++) {
      measurements.push(await monitor.captureMetrics());
    }
    const duration = performance.now() - start;

    expect(measurements.length).toBe(10);
    // All measurements should be valid
    measurements.forEach(m => {
      expect(m.isValidMeasurement).toBe(true);
    });

    // Should complete within 500ms for 10 measurements
    expect(duration).toBeLessThan(500);
  });
});