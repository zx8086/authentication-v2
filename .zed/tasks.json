[
  {
    "label": "kong: status",
    "command": "curl -sf http://localhost:8001/status | jq .",
    "use_new_terminal": false,
    "reveal": "always",
  },
  {
    "label": "kong: list services",
    "command": "curl -sf http://localhost:8001/services | jq .",
    "use_new_terminal": false,
    "reveal": "always",
  },
  {
    "label": "kong: list routes",
    "command": "curl -sf http://localhost:8001/routes | jq .",
    "use_new_terminal": false,
    "reveal": "always",
  },
  {
    "label": "kong: list plugins",
    "command": "curl -sf http://localhost:8001/plugins | jq .",
    "use_new_terminal": false,
    "reveal": "always",
  },
  {
    "label": "kong: sync config (decK)",
    "command": "deck gateway sync kong/kong.yml --kong-addr http://localhost:8001",
    "use_new_terminal": false,
    "reveal": "always",
  },
  {
    "label": "kong: dump config (decK)",
    "command": "deck gateway dump --kong-addr http://localhost:8001 | jq .",
    "use_new_terminal": false,
    "reveal": "always",
  },
  {
    "label": "kong: diff config (decK)",
    "command": "deck gateway diff kong/kong.yml --kong-addr http://localhost:8001",
    "use_new_terminal": false,
    "reveal": "always",
  },
  {
    "label": "kong: view logs",
    "command": "docker logs -f $(docker ps --filter 'name=kong' --filter 'ancestor=kong/kong-gateway:3.9' -q | head -1)",
    "use_new_terminal": true,
    "allow_concurrent_runs": false,
  },
  {
    "label": "kong: restart",
    "command": "docker restart $(docker ps --filter 'name=kong' --filter 'ancestor=kong/kong-gateway:3.9' -q | head -1) && echo '[OK] Kong restarted'",
    "use_new_terminal": false,
    "reveal": "always",
  },
  {
    "label": "redis: ping",
    "command": "docker exec $(docker ps --filter 'name=redis' -q | head -1) redis-cli ping",
    "use_new_terminal": false,
    "reveal": "always",
  },
  {
    "label": "redis: monitor (live commands)",
    "command": "docker exec -it $(docker ps --filter 'name=redis' -q | head -1) redis-cli monitor",
    "use_new_terminal": true,
    "allow_concurrent_runs": false,
  },
  {
    "label": "redis: info stats",
    "command": "docker exec $(docker ps --filter 'name=redis' -q | head -1) redis-cli info stats",
    "use_new_terminal": false,
    "reveal": "always",
  },
  {
    "label": "redis: keys (all)",
    "command": "docker exec $(docker ps --filter 'name=redis' -q | head -1) redis-cli keys '*'",
    "use_new_terminal": false,
    "reveal": "always",
  },
  {
    "label": "redis: flush all",
    "command": "docker exec $(docker ps --filter 'name=redis' -q | head -1) redis-cli flushall && echo '[OK] Redis flushed'",
    "use_new_terminal": false,
    "reveal": "always",
  },
  {
    "label": "redis: interactive CLI",
    "command": "docker exec -it $(docker ps --filter 'name=redis' -q | head -1) redis-cli",
    "use_new_terminal": true,
    "allow_concurrent_runs": false,
  },
  {
    "label": "redis: start (standalone)",
    "command": "docker run -d --name auth-redis -p 6379:6379 --restart unless-stopped redis:7-alpine redis-server --appendonly yes --maxmemory 128mb --maxmemory-policy allkeys-lru && echo '[OK] Redis started on localhost:6379'",
    "use_new_terminal": false,
    "reveal": "always",
  },
  {
    "label": "redis: stop",
    "command": "docker stop auth-redis 2>/dev/null && echo '[OK] Redis stopped' || echo '[INFO] Redis not running'",
    "use_new_terminal": false,
    "reveal": "always",
  },
  {
    "label": "redis: remove",
    "command": "docker rm auth-redis 2>/dev/null && echo '[OK] Redis container removed' || echo '[INFO] No container to remove'",
    "use_new_terminal": false,
    "reveal": "always",
  },
  {
    "label": "redis: restart (standalone)",
    "command": "docker stop auth-redis 2>/dev/null; docker rm auth-redis 2>/dev/null; docker run -d --name auth-redis -p 6379:6379 --restart unless-stopped redis:7-alpine redis-server --appendonly yes --maxmemory 128mb --maxmemory-policy allkeys-lru && echo '[OK] Redis restarted on localhost:6379'",
    "use_new_terminal": false,
    "reveal": "always",
  },
  {
    "label": "redis: logs",
    "command": "docker logs -f auth-redis",
    "use_new_terminal": true,
    "allow_concurrent_runs": false,
  },
  {
    "label": "redis: status",
    "command": "docker ps --filter name=auth-redis --format 'table {{.Names}}\\t{{.Status}}\\t{{.Ports}}' || docker ps --filter 'name=redis' --format 'table {{.Names}}\\t{{.Status}}\\t{{.Ports}}'",
    "use_new_terminal": false,
    "reveal": "always",
  },
  {
    "label": "redis: bigkeys",
    "command": "docker exec $(docker ps --filter 'name=redis' -q | head -1) redis-cli --bigkeys",
    "use_new_terminal": false,
    "reveal": "always",
  },
  {
    "label": "redis: memkeys",
    "command": "docker exec $(docker ps --filter 'name=redis' -q | head -1) redis-cli --memkeys",
    "use_new_terminal": false,
    "reveal": "always",
  },
  {
    "label": "redis: scan auth keys",
    "command": "docker exec $(docker ps --filter 'name=redis' -q | head -1) redis-cli --scan --pattern '*auth_service*'",
    "use_new_terminal": false,
    "reveal": "always",
  },
  {
    "label": "valkey: ping",
    "command": "docker exec $(docker ps --filter 'name=valkey' -q | head -1) valkey-cli ping",
    "use_new_terminal": false,
    "reveal": "always",
  },
  {
    "label": "valkey: info server",
    "command": "docker exec $(docker ps --filter 'name=valkey' -q | head -1) valkey-cli info server",
    "use_new_terminal": false,
    "reveal": "always",
  },
  {
    "label": "valkey: info stats",
    "command": "docker exec $(docker ps --filter 'name=valkey' -q | head -1) valkey-cli info stats",
    "use_new_terminal": false,
    "reveal": "always",
  },
  {
    "label": "valkey: keys (all)",
    "command": "docker exec $(docker ps --filter 'name=valkey' -q | head -1) valkey-cli keys '*'",
    "use_new_terminal": false,
    "reveal": "always",
  },
  {
    "label": "valkey: flush all",
    "command": "docker exec $(docker ps --filter 'name=valkey' -q | head -1) valkey-cli flushall && echo '[OK] Valkey flushed'",
    "use_new_terminal": false,
    "reveal": "always",
  },
  {
    "label": "valkey: interactive CLI",
    "command": "docker exec -it $(docker ps --filter 'name=valkey' -q | head -1) valkey-cli",
    "use_new_terminal": true,
    "allow_concurrent_runs": false,
  },
  {
    "label": "valkey: start (standalone)",
    "command": "docker run -d --name auth-valkey -p 6380:6379 --restart unless-stopped valkey/valkey:8-alpine valkey-server --appendonly yes --maxmemory 128mb --maxmemory-policy allkeys-lru && echo '[OK] Valkey started on localhost:6380'",
    "use_new_terminal": false,
    "reveal": "always",
  },
  {
    "label": "valkey: stop",
    "command": "docker stop auth-valkey 2>/dev/null && echo '[OK] Valkey stopped' || echo '[INFO] Valkey not running'",
    "use_new_terminal": false,
    "reveal": "always",
  },
  {
    "label": "valkey: remove",
    "command": "docker rm auth-valkey 2>/dev/null && echo '[OK] Valkey container removed' || echo '[INFO] No container to remove'",
    "use_new_terminal": false,
    "reveal": "always",
  },
  {
    "label": "valkey: restart (standalone)",
    "command": "docker stop auth-valkey 2>/dev/null; docker rm auth-valkey 2>/dev/null; docker run -d --name auth-valkey -p 6380:6379 --restart unless-stopped valkey/valkey:8-alpine valkey-server --appendonly yes --maxmemory 128mb --maxmemory-policy allkeys-lru && echo '[OK] Valkey restarted on localhost:6380'",
    "use_new_terminal": false,
    "reveal": "always",
  },
  {
    "label": "valkey: logs",
    "command": "docker logs -f auth-valkey",
    "use_new_terminal": true,
    "allow_concurrent_runs": false,
  },
  {
    "label": "valkey: status",
    "command": "docker ps --filter name=auth-valkey --format 'table {{.Names}}\\t{{.Status}}\\t{{.Ports}}' || docker ps --filter 'name=valkey' --format 'table {{.Names}}\\t{{.Status}}\\t{{.Ports}}'",
    "use_new_terminal": false,
    "reveal": "always",
  },
  {
    "label": "dev: start with Valkey",
    "command": "lsof -ti :3000 | xargs kill -9 2>/dev/null || true; REDIS_URL=redis://localhost:6380 bun --watch src/index.ts",
    "use_new_terminal": true,
    "allow_concurrent_runs": false,
  },
  {
    "label": "server: health check (Valkey)",
    "command": "curl -sf http://localhost:3000/health > /tmp/health.json && jq '.dependencies.cache' /tmp/health.json && echo '[OK] Server healthy with Valkey' || echo '[FAIL] Server not responding'",
    "use_new_terminal": false,
    "reveal": "always",
  },
  {
    "label": "postgres: interactive psql",
    "command": "docker exec -it $(docker ps --filter 'name=kong-db' -q | head -1) psql -U kong -d kong",
    "use_new_terminal": true,
    "allow_concurrent_runs": false,
  },
  {
    "label": "postgres: list tables",
    "command": "docker exec $(docker ps --filter 'name=kong-db' -q | head -1) psql -U kong -d kong -c '\\dt'",
    "use_new_terminal": false,
    "reveal": "always",
  },
  {
    "label": "postgres: kong services (SQL)",
    "command": "docker exec $(docker ps --filter 'name=kong-db' -q | head -1) psql -U kong -d kong -c 'SELECT id, name, host, port, protocol FROM services;'",
    "use_new_terminal": false,
    "reveal": "always",
  },
  {
    "label": "postgres: kong routes (SQL)",
    "command": "docker exec $(docker ps --filter 'name=kong-db' -q | head -1) psql -U kong -d kong -c 'SELECT id, name, paths, service_id FROM routes;'",
    "use_new_terminal": false,
    "reveal": "always",
  },
  {
    "label": "postgres: db size",
    "command": "docker exec $(docker ps --filter 'name=kong-db' -q | head -1) psql -U kong -d kong -c \"SELECT pg_size_pretty(pg_database_size('kong'));\"",
    "use_new_terminal": false,
    "reveal": "always",
  },
  {
    "label": "infra: status check",
    "command": "echo '--- Kong ---' && curl -sf http://localhost:8001/status > /dev/null && echo '[OK] Kong OK' || echo '[FAIL] Kong DOWN'; echo '--- Redis ---' && docker exec $(docker ps --filter 'name=redis' -q | head -1) redis-cli ping || echo '[FAIL] Redis DOWN'; echo '--- Postgres ---' && docker exec $(docker ps --filter 'name=kong-db' -q | head -1) pg_isready -U kong > /dev/null && echo '[OK] Postgres OK' || echo '[FAIL] Postgres DOWN'",
    "use_new_terminal": false,
    "reveal": "always",
  },
  {
    "label": "devcontainer: up",
    "command": "docker compose -f .devcontainer/docker-compose.yml up -d && echo '[OK] Devcontainer started'",
    "use_new_terminal": false,
    "reveal": "always",
  },
  {
    "label": "deps: up (Kong + Redis)",
    "command": "docker compose -f .devcontainer/docker-compose.yml up -d kong kong-db kong-migrations redis && echo '[OK] Kong + Redis started (localhost:8001, localhost:6379)'",
    "use_new_terminal": false,
    "reveal": "always",
  },
  {
    "label": "deps: up (Kong + Valkey)",
    "command": "docker compose -f .devcontainer/docker-compose.yml up -d kong kong-db kong-migrations valkey && echo '[OK] Kong + Valkey started (localhost:8001, localhost:6380)'",
    "use_new_terminal": false,
    "reveal": "always",
  },
  {
    "label": "deps: up (all)",
    "command": "docker compose -f .devcontainer/docker-compose.yml up -d kong kong-db kong-migrations redis valkey && echo '[OK] Kong + Redis + Valkey started'",
    "use_new_terminal": false,
    "reveal": "always",
  },
  {
    "label": "deps: down",
    "command": "docker compose -f .devcontainer/docker-compose.yml stop kong kong-db redis valkey && echo '[OK] Dependencies stopped'",
    "use_new_terminal": false,
    "reveal": "always",
  },
  {
    "label": "docker: ps",
    "command": "docker ps --format 'table {{.Names}}\\t{{.Status}}\\t{{.Ports}}'",
    "use_new_terminal": false,
    "reveal": "always",
  },
  {
    "label": "docker: ps (all)",
    "command": "docker ps -a --format 'table {{.Names}}\\t{{.Status}}\\t{{.Ports}}'",
    "use_new_terminal": false,
    "reveal": "always",
  },
  {
    "label": "devcontainer: down",
    "command": "docker compose -f .devcontainer/docker-compose.yml down && echo '[OK] Devcontainer stopped'",
    "use_new_terminal": false,
    "reveal": "always",
  },
  {
    "label": "devcontainer: down (clean volumes)",
    "command": "docker compose -f .devcontainer/docker-compose.yml down -v && echo '[OK] Devcontainer stopped and volumes removed'",
    "use_new_terminal": false,
    "reveal": "always",
  },
  {
    "label": "devcontainer: logs",
    "command": "docker compose -f .devcontainer/docker-compose.yml logs -f",
    "use_new_terminal": true,
    "allow_concurrent_runs": false,
  },
  {
    "label": "devcontainer: status",
    "command": "docker compose -f .devcontainer/docker-compose.yml ps",
    "use_new_terminal": false,
    "reveal": "always",
  },
  {
    "label": "dev: start (watch mode)",
    "command": "bun --watch src/index.ts",
    "use_new_terminal": true,
    "allow_concurrent_runs": false,
  },
  {
    "label": "dev: start (devcontainer env)",
    "command": "bun --env-file=.env.devcontainer run dev",
    "use_new_terminal": true,
    "allow_concurrent_runs": false,
  },
  {
    "label": "dev: clean restart",
    "command": "lsof -ti :3000 | xargs kill -9 2>/dev/null || true; bun --watch src/index.ts",
    "use_new_terminal": true,
    "allow_concurrent_runs": false,
  },
  {
    "label": "dev: quickstart",
    "command": "lsof -ti :3000 | xargs kill -9 2>/dev/null || true; bun scripts/generate-openapi.ts && bun --watch src/index.ts",
    "use_new_terminal": true,
    "allow_concurrent_runs": false,
  },
  {
    "label": "server: kill (port 3000)",
    "command": "lsof -ti :3000 | xargs kill -9 2>/dev/null && echo '[OK] Process on port 3000 killed' || echo '[INFO] No process on port 3000'",
    "use_new_terminal": false,
    "reveal": "always",
  },
  {
    "label": "server: health check",
    "command": "curl -sf http://localhost:3000/health > /tmp/health.json && jq . /tmp/health.json && echo '[OK] Server healthy' || echo '[FAIL] Server not responding'",
    "use_new_terminal": false,
    "reveal": "always",
  },
  {
    "label": "test: e2e (direct)",
    "command": "bunx playwright test",
    "use_new_terminal": true,
    "allow_concurrent_runs": false,
  },
  {
    "label": "test: e2e (via Kong)",
    "command": "API_BASE_URL=http://localhost:8000 E2E_HOST_HEADER=auth.local bunx playwright test",
    "use_new_terminal": true,
    "allow_concurrent_runs": false,
  },
  {
    "label": "test: e2e UI",
    "command": "bunx playwright test --ui",
    "use_new_terminal": true,
    "allow_concurrent_runs": false,
  },
  {
    "label": "test: bun (all)",
    "command": "bun test",
    "use_new_terminal": true,
    "allow_concurrent_runs": false,
  },
  {
    "label": "test: bun (watch)",
    "command": "bun test --watch",
    "use_new_terminal": true,
    "allow_concurrent_runs": false,
  },
  {
    "label": "test: k6 smoke (quick)",
    "command": "bun run test:k6:quick",
    "use_new_terminal": true,
    "allow_concurrent_runs": false,
  },
  {
    "label": "quality: check (all)",
    "command": "bun run quality:check",
    "use_new_terminal": false,
    "reveal": "always",
  },
  {
    "label": "quality: fix",
    "command": "bun run quality:fix",
    "use_new_terminal": false,
    "reveal": "always",
  },
  {
    "label": "docs: generate OpenAPI",
    "command": "bun scripts/generate-openapi.ts && echo '[OK] OpenAPI spec generated'",
    "use_new_terminal": false,
    "reveal": "always",
  },
  {
    "label": "github: security alerts (open only)",
    "command": "gh api repos/:owner/:repo/code-scanning/alerts --jq '.[] | select(.state == \"open\") | {rule: .rule.id, severity: .rule.security_severity_level, tool: .tool.name, file: .most_recent_instance.location.path}' | head -50 || echo '[OK] No open alerts'",
    "use_new_terminal": false,
    "reveal": "always",
  },
  {
    "label": "github: security alerts (all)",
    "command": "gh api repos/:owner/:repo/code-scanning/alerts --jq '.[] | {rule: .rule.id, severity: .rule.security_severity_level, state: .state, tool: .tool.name}' | head -50",
    "use_new_terminal": false,
    "reveal": "always",
  },
  {
    "label": "github: security alerts (Dependabot)",
    "command": "gh api repos/:owner/:repo/dependabot/alerts --jq '.[] | select(.state == \"open\") | {package: .dependency.package.name, severity: .security_advisory.severity, cve: .security_advisory.cve_id}' | head -50 || echo '[OK] No open Dependabot alerts'",
    "use_new_terminal": false,
    "reveal": "always",
  },
  {
    "label": "github: trigger security audit",
    "command": "gh workflow run 'Comprehensive Security Audit' --ref master && echo '[OK] Security audit triggered - run: gh run list --workflow=\"Comprehensive Security Audit\" --limit=1'",
    "use_new_terminal": false,
    "reveal": "always",
  },
  {
    "label": "github: docker security (Trivy)",
    "command": "gh run list --workflow=build-and-deploy.yml --limit=1 --json databaseId,conclusion -q '.[0].databaseId' | xargs -I{} gh run view {} --log | grep -E '(CRITICAL|HIGH|MEDIUM|CVE-)' | head -100",
    "use_new_terminal": false,
    "reveal": "always",
  },
  {
    "label": "github: latest workflow run",
    "command": "gh run list --workflow=build-and-deploy.yml --limit=5 --json databaseId,displayTitle,conclusion,createdAt -q '.[] | \"\\(.createdAt) [\\(.conclusion)] \\(.displayTitle)\"'",
    "use_new_terminal": false,
    "reveal": "always",
  },
  {
    "label": "github: workflow artifacts",
    "command": "gh run list --workflow=build-and-deploy.yml --limit=1 --json databaseId -q '.[0].databaseId' | xargs -I{} gh api repos/:owner/:repo/actions/runs/{}/artifacts --jq '.artifacts[] | {name: .name, size: .size_in_bytes, expires: .expires_at}'",
    "use_new_terminal": false,
    "reveal": "always",
  },
  {
    "label": "otel: status (all endpoints)",
    "command": "set -a && source .env && set +a && echo '--- OTLP Base Endpoint ---' && curl -sf -o /dev/null -w '%{http_code}' $OTEL_EXPORTER_OTLP_ENDPOINT 2>/dev/null && echo ' [OK]' || echo ' [FAIL or no response expected]'; echo '--- Traces Endpoint ---' && curl -sf -X POST -H 'Content-Type: application/json' -d '{}' $OTEL_EXPORTER_OTLP_TRACES_ENDPOINT -o /dev/null -w '%{http_code}' 2>/dev/null && echo ' [OK]' || echo ' [FAIL]'; echo '--- Metrics Endpoint ---' && curl -sf -X POST -H 'Content-Type: application/json' -d '{}' $OTEL_EXPORTER_OTLP_METRICS_ENDPOINT -o /dev/null -w '%{http_code}' 2>/dev/null && echo ' [OK]' || echo ' [FAIL]'; echo '--- Logs Endpoint ---' && curl -sf -X POST -H 'Content-Type: application/json' -d '{}' $OTEL_EXPORTER_OTLP_LOGS_ENDPOINT -o /dev/null -w '%{http_code}' 2>/dev/null && echo ' [OK]' || echo ' [FAIL]'",
    "use_new_terminal": false,
    "reveal": "always",
  },
  {
    "label": "otel: ping collector",
    "command": "set -a && source .env && set +a && curl -sf --max-time 3 $OTEL_EXPORTER_OTLP_ENDPOINT && echo '[OK] OTLP collector reachable' || echo '[FAIL] OTLP collector not reachable at '$OTEL_EXPORTER_OTLP_ENDPOINT",
    "use_new_terminal": false,
    "reveal": "always",
  },
  {
    "label": "otel: traces endpoint check",
    "command": "set -a && source .env && set +a && curl -sf --max-time 3 -X POST -H 'Content-Type: application/json' -d '{\"resourceSpans\":[]}' $OTEL_EXPORTER_OTLP_TRACES_ENDPOINT -w '\\nHTTP Status: %{http_code}\\n' && echo '[OK] Traces endpoint accepting data' || echo '[FAIL] Traces endpoint not responding'",
    "use_new_terminal": false,
    "reveal": "always",
  },
  {
    "label": "otel: metrics endpoint check",
    "command": "set -a && source .env && set +a && curl -sf --max-time 3 -X POST -H 'Content-Type: application/json' -d '{\"resourceMetrics\":[]}' $OTEL_EXPORTER_OTLP_METRICS_ENDPOINT -w '\\nHTTP Status: %{http_code}\\n' && echo '[OK] Metrics endpoint accepting data' || echo '[FAIL] Metrics endpoint not responding'",
    "use_new_terminal": false,
    "reveal": "always",
  },
  {
    "label": "otel: logs endpoint check",
    "command": "set -a && source .env && set +a && curl -sf --max-time 3 -X POST -H 'Content-Type: application/json' -d '{\"resourceLogs\":[]}' $OTEL_EXPORTER_OTLP_LOGS_ENDPOINT -w '\\nHTTP Status: %{http_code}\\n' && echo '[OK] Logs endpoint accepting data' || echo '[FAIL] Logs endpoint not responding'",
    "use_new_terminal": false,
    "reveal": "always",
  },
  {
    "label": "otel: show config",
    "command": "set -a && source .env && set +a && echo 'OTEL_SERVICE_NAME='$OTEL_SERVICE_NAME; echo 'OTEL_EXPORTER_OTLP_ENDPOINT='$OTEL_EXPORTER_OTLP_ENDPOINT; echo 'OTEL_EXPORTER_OTLP_TRACES_ENDPOINT='$OTEL_EXPORTER_OTLP_TRACES_ENDPOINT; echo 'OTEL_EXPORTER_OTLP_METRICS_ENDPOINT='$OTEL_EXPORTER_OTLP_METRICS_ENDPOINT; echo 'OTEL_EXPORTER_OTLP_LOGS_ENDPOINT='$OTEL_EXPORTER_OTLP_LOGS_ENDPOINT",
    "use_new_terminal": false,
    "reveal": "always",
  },
  {
    "label": "otel: network connectivity test",
    "command": "set -a && source .env && set +a && OTEL_HOST=$(echo $OTEL_EXPORTER_OTLP_ENDPOINT | sed 's|http://||' | cut -d: -f1); OTEL_PORT=$(echo $OTEL_EXPORTER_OTLP_ENDPOINT | sed 's|http://||' | cut -d: -f2 | cut -d/ -f1); echo 'Testing '$OTEL_HOST':'$OTEL_PORT; nc -zv -w 3 $OTEL_HOST $OTEL_PORT 2>&1 && echo '[OK] Port reachable' || echo '[FAIL] Port not reachable'",
    "use_new_terminal": false,
    "reveal": "always",
  },
  {
    "label": "otel: service telemetry health",
    "command": "curl -sf http://localhost:3000/health/telemetry | jq . && echo '[OK] Service telemetry healthy' || echo '[FAIL] Service telemetry endpoint not responding'",
    "use_new_terminal": false,
    "reveal": "always",
  },
  {
    "label": "otel: ssh tunnel start",
    "command": "OTEL_REMOTE=192.168.178.3; OTEL_PORT=4318; if lsof -i :${OTEL_PORT} 2>/dev/null | grep -q ssh; then echo \"[INFO] SSH tunnel already running on port ${OTEL_PORT}\"; else ssh -L ${OTEL_PORT}:127.0.0.1:${OTEL_PORT} pi@${OTEL_REMOTE} -N -f && echo \"[OK] SSH tunnel started: localhost:${OTEL_PORT} -> ${OTEL_REMOTE}:${OTEL_PORT}\"; fi",
    "use_new_terminal": false,
    "reveal": "always",
  },
  {
    "label": "otel: ssh tunnel stop",
    "command": "set -a && source .env && set +a && OTEL_PORT=$(echo $OTEL_EXPORTER_OTLP_ENDPOINT | sed 's|http://||' | cut -d: -f2 | cut -d/ -f1); PID=$(lsof -t -i :$OTEL_PORT | head -1); if [ -n \"$PID\" ]; then kill $PID && echo '[OK] SSH tunnel stopped (PID '$PID')'; else echo '[INFO] No SSH tunnel running on port '$OTEL_PORT; fi",
    "use_new_terminal": false,
    "reveal": "always",
  },
  {
    "label": "otel: ssh tunnel status",
    "command": "set -a && source .env && set +a && OTEL_PORT=$(echo $OTEL_EXPORTER_OTLP_ENDPOINT | sed 's|http://||' | cut -d: -f2 | cut -d/ -f1); lsof -i :$OTEL_PORT | grep ssh && echo '[OK] SSH tunnel active on port '$OTEL_PORT || echo '[INFO] No SSH tunnel on port '$OTEL_PORT",
    "use_new_terminal": false,
    "reveal": "always",
  },
]
