/* src/config/envMapping.ts */

// Pillar 2: Environment Variable Mapping
export const envVarMapping = {
  server: {
    port: "PORT",
    nodeEnv: "NODE_ENV",
    maxRequestBodySize: "MAX_REQUEST_BODY_SIZE",
    requestTimeoutMs: "REQUEST_TIMEOUT_MS",
  },
  jwt: {
    authority: "KONG_JWT_AUTHORITY",
    audience: "KONG_JWT_AUDIENCE",
    issuer: "KONG_JWT_ISSUER",
    keyClaimName: "KONG_JWT_KEY_CLAIM_NAME",
    expirationMinutes: "JWT_EXPIRATION_MINUTES",
  },
  kong: {
    mode: "KONG_MODE",
    adminUrl: "KONG_ADMIN_URL",
    adminToken: ["KONG", "ADMIN", "TOKEN"].join("_"),
    highAvailability: "HIGH_AVAILABILITY",
    circuitBreakerEnabled: "CIRCUIT_BREAKER_ENABLED",
    circuitBreakerTimeout: "CIRCUIT_BREAKER_TIMEOUT",
    circuitBreakerErrorThreshold: "CIRCUIT_BREAKER_ERROR_THRESHOLD",
    circuitBreakerResetTimeout: "CIRCUIT_BREAKER_RESET_TIMEOUT",
    circuitBreakerVolumeThreshold: "CIRCUIT_BREAKER_VOLUME_THRESHOLD",
    circuitBreakerRollingCountTimeout: "CIRCUIT_BREAKER_ROLLING_COUNT_TIMEOUT",
    circuitBreakerRollingCountBuckets: "CIRCUIT_BREAKER_ROLLING_COUNT_BUCKETS",
    secretCreationMaxRetries: "KONG_SECRET_CREATION_MAX_RETRIES",
    maxHeaderLength: "KONG_MAX_HEADER_LENGTH",
  },
  caching: {
    highAvailability: "HIGH_AVAILABILITY",
    redisUrl: "REDIS_URL",
    redisPassword: "REDIS_PASSWORD",
    redisDb: "REDIS_DB",
    staleDataToleranceMinutes: "STALE_DATA_TOLERANCE_MINUTES",
    maxMemoryEntries: "CACHE_MAX_MEMORY_ENTRIES",
    healthCheckTtlMs: "CACHE_HEALTH_TTL_MS",
    redisMaxRetries: "REDIS_MAX_RETRIES",
    redisConnectionTimeout: "REDIS_CONNECTION_TIMEOUT",
    resilience: {
      circuitBreaker: {
        enabled: "CACHE_CB_ENABLED",
        failureThreshold: "CACHE_CB_FAILURE_THRESHOLD",
        resetTimeout: "CACHE_CB_RESET_TIMEOUT",
        successThreshold: "CACHE_CB_SUCCESS_THRESHOLD",
      },
      reconnect: {
        maxAttempts: "CACHE_RECONNECT_MAX_ATTEMPTS",
        baseDelayMs: "CACHE_RECONNECT_BASE_DELAY_MS",
        maxDelayMs: "CACHE_RECONNECT_MAX_DELAY_MS",
        cooldownMs: "CACHE_RECONNECT_COOLDOWN_MS",
      },
      healthMonitor: {
        enabled: "CACHE_HEALTH_MONITOR_ENABLED",
        intervalMs: "CACHE_HEALTH_MONITOR_INTERVAL_MS",
        unhealthyThreshold: "CACHE_HEALTH_MONITOR_UNHEALTHY_THRESHOLD",
        healthyThreshold: "CACHE_HEALTH_MONITOR_HEALTHY_THRESHOLD",
        pingTimeoutMs: "CACHE_HEALTH_MONITOR_PING_TIMEOUT_MS",
      },
      operationTimeouts: {
        get: "CACHE_TIMEOUT_GET_MS",
        set: "CACHE_TIMEOUT_SET_MS",
        delete: "CACHE_TIMEOUT_DELETE_MS",
        scan: "CACHE_TIMEOUT_SCAN_MS",
        ping: "CACHE_TIMEOUT_PING_MS",
        connect: "CACHE_TIMEOUT_CONNECT_MS",
      },
    },
  },
  telemetry: {
    serviceName: "OTEL_SERVICE_NAME",
    serviceVersion: "OTEL_SERVICE_VERSION",
    environment: "NODE_ENV",
    mode: "TELEMETRY_MODE",
    logLevel: "LOG_LEVEL",
    endpoint: "OTEL_EXPORTER_OTLP_ENDPOINT",
    logsEndpoint: "OTEL_EXPORTER_OTLP_LOGS_ENDPOINT",
    tracesEndpoint: "OTEL_EXPORTER_OTLP_TRACES_ENDPOINT",
    metricsEndpoint: "OTEL_EXPORTER_OTLP_METRICS_ENDPOINT",
    exportTimeout: "OTEL_EXPORTER_OTLP_TIMEOUT",
    batchSize: "OTEL_BSP_MAX_EXPORT_BATCH_SIZE",
    maxQueueSize: "OTEL_BSP_MAX_QUEUE_SIZE",
    circuitBreakerFailureThreshold: "TELEMETRY_CB_FAILURE_THRESHOLD",
    circuitBreakerRecoveryTimeout: "TELEMETRY_CB_RECOVERY_TIMEOUT",
    circuitBreakerSuccessThreshold: "TELEMETRY_CB_SUCCESS_THRESHOLD",
    circuitBreakerMonitoringInterval: "TELEMETRY_CB_MONITORING_INTERVAL",
  },
  profiling: {
    enabled: "PROFILING_ENABLED",
  },
  continuousProfiling: {
    enabled: "CONTINUOUS_PROFILING_ENABLED",
    autoTriggerOnSlaViolation: "CONTINUOUS_PROFILING_AUTO_TRIGGER_ON_SLA",
    slaViolationThrottleMinutes: "CONTINUOUS_PROFILING_THROTTLE_MINUTES",
    outputDir: "CONTINUOUS_PROFILING_OUTPUT_DIR",
    maxConcurrentProfiles: "CONTINUOUS_PROFILING_MAX_CONCURRENT",
    rollingBufferSize: "CONTINUOUS_PROFILING_BUFFER_SIZE",
  },
  apiInfo: {
    title: "API_TITLE",
    description: "API_DESCRIPTION",
    version: "API_VERSION",
    contactName: "API_CONTACT_NAME",
    contactEmail: "API_CONTACT_EMAIL",
    licenseName: "API_LICENSE_NAME",
    licenseIdentifier: "API_LICENSE_IDENTIFIER",
    cors: {
      origin: "API_CORS_ORIGIN",
      allowHeaders: "API_CORS_ALLOW_HEADERS",
      allowMethods: "API_CORS_ALLOW_METHODS",
      maxAge: "API_CORS_MAX_AGE",
    },
    // Legacy backward compatibility
    corsLegacy: "API_CORS",
  },
} as const;
