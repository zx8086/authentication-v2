# GitLab CI/CD pipeline for Bun authentication service
stages:
  - test
  - security
  - build
  - deploy

variables:
  # Docker configuration
  DOCKER_DRIVER: overlay2
  DOCKER_BUILDKIT: 1
  
  # Image configuration
  IMAGE_NAME: pvh-authentication-bun
  BUN_VERSION: "1.1.35"
  
  # Registry configuration
  ECR_REGISTRY: "${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com"
  ECR_REPOSITORY: shared-services-authentication-bun
  
  # AWS configuration
  AWS_REGION: eu-central-1
  AWS_DEFAULT_REGION: eu-central-1

# Include templates
include:
  - template: Security/SAST.gitlab-ci.yml
  - template: Security/Dependency-Scanning.gitlab-ci.yml

# Test stage
test:unit:
  stage: test
  image: oven/bun:${BUN_VERSION}
  before_script:
    - bun --version
    - bun install --frozen-lockfile
  script:
    - bun run typecheck
    - bun test --coverage
  artifacts:
    reports:
      coverage_report:
        coverage_format: cobertura
        path: coverage/cobertura-coverage.xml
      junit: test-results.xml
    paths:
      - coverage/
    expire_in: 1 week
  coverage: '/All files[^|]*\|[^|]*\s+([\d\.]+)/'
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - if: $CI_COMMIT_TAG

# Build stage
build:docker:
  stage: build
  image: docker:24
  services:
    - docker:dind
  before_script:
    - echo $CI_REGISTRY_PASSWORD | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY
    - apk add --no-cache aws-cli
    - aws ecr get-login-password --region $AWS_REGION | docker login --username AWS --password-stdin $ECR_REGISTRY
  script:
    # Build with cache optimization
    - |
      docker build \
        --cache-from $ECR_REGISTRY/$ECR_REPOSITORY:latest \
        --cache-from $ECR_REGISTRY/$ECR_REPOSITORY:$CI_COMMIT_SHORT_SHA \
        --build-arg BUILDKIT_INLINE_CACHE=1 \
        -t $ECR_REGISTRY/$ECR_REPOSITORY:$CI_COMMIT_SHORT_SHA \
        -t $ECR_REGISTRY/$ECR_REPOSITORY:latest .
    
    # Push images
    - docker push $ECR_REGISTRY/$ECR_REPOSITORY:$CI_COMMIT_SHORT_SHA
    - docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
  rules:
    - if: $CI_COMMIT_BRANCH == "develop"
    - if: $CI_COMMIT_BRANCH == "main"
    - if: $CI_COMMIT_TAG =~ /^v.*$/

# Deployment template
.deploy_template: &deploy_template
  stage: deploy
  image: 
    name: amazon/aws-cli:latest
    entrypoint: [""]
  before_script:
    - yum install -y jq
    # Assume deployment role
    - |
      ROLE_OUTPUT=$(aws sts assume-role \
        --role-arn $AWS_DEPLOYMENT_ROLE_ARN \
        --role-session-name "auth-bun-$ENV-deploy-$CI_COMMIT_SHORT_SHA" \
        --duration-seconds 3600)
    - export AWS_ACCESS_KEY_ID=$(echo $ROLE_OUTPUT | jq -r .Credentials.AccessKeyId)
    - export AWS_SECRET_ACCESS_KEY=$(echo $ROLE_OUTPUT | jq -r .Credentials.SecretAccessKey)
    - export AWS_SESSION_TOKEN=$(echo $ROLE_OUTPUT | jq -r .Credentials.SessionToken)
  script:
    # Update ECS service with new image
    - |
      aws ecs update-service \
        --cluster $CLUSTER_NAME \
        --service authentication-service \
        --force-new-deployment \
        --region $AWS_REGION

deploy:dev:
  <<: *deploy_template
  variables:
    ENV: dev
    CLUSTER_NAME: shared-services-dev
    AWS_DEPLOYMENT_ROLE_ARN: "arn:aws:iam::352896877281:role/shared-services-deployment-role"
  rules:
    - if: $CI_COMMIT_BRANCH == "develop"
      when: manual
  environment:
    name: development

deploy:production:
  <<: *deploy_template
  variables:
    ENV: prd
    CLUSTER_NAME: shared-services-prd
    AWS_DEPLOYMENT_ROLE_ARN: "arn:aws:iam::399987695868:role/shared-services-deployment-role"
  rules:
    - if: $CI_COMMIT_TAG =~ /^v.*$/
      when: manual
  environment:
    name: production